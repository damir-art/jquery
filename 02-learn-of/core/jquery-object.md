# The jQuery Object
Объект jQuery это не массив, а коллекция.

При создании новых элементов (или выборе существующих) jQuery возвращает элементы в коллекции. Многие разработчики, плохо знакомые с jQuery, предполагают, что эта коллекция является массивом. В конце концов, у него есть последовательность элементов DOM с нулевым индексом, некоторые знакомые функции массива и свойство `.length`. На самом деле объект jQuery сложнее.

## DOM and DOM Elements
Объектная модель документа (сокращенно DOM) - это представление HTML-документа. Она может содержать любое количество элементов DOM. На высоком уровне элемент DOM можно рассматривать как "часть" веб-страницы. Она может содержать текст и/или другие элементы DOM. Элементы DOM описываются типом, например `<div>`, `<a>` или `<p>`, и любым количеством атрибутов, например `src`, `href`, `class` и т.д. Более подробное описание см. в официальной спецификации DOM от W3C.

Элементы имеют свойства, как и любой объект JavaScript. Среди этих свойств есть такие атрибуты, как `.tagName`, и такие методы, как `.appendChild()`. Эти свойства - единственный способ взаимодействия с веб-страницей через JavaScript.

## The jQuery Object
Оказывается, работать напрямую с элементами DOM может быть неудобно. Объект jQuery определяет множество методов, упрощающих работу разработчиков. Некоторые преимущества объекта jQuery включают в себя:

**Совместимость**. Реализация методов элементов зависит от поставщиков и версий браузеров. Следующий фрагмент кода пытается установить внутренний HTML-код элемента `<tr>`, хранящегося в `target`.

    var target = document.getElementById( "target" );
    target.innerHTML = "<td>Hello <b>World</b>!</td>";

Это работает во многих случаях, но не работает в большинстве версий Internet Explorer. В этом случае рекомендуется вместо этого использовать чистые методы DOM. При заключении `target` элемента в объект jQuery эти пограничные случаи учитываются, и ожидаемый результат достигается во всех поддерживаемых браузерах.

    // Setting the inner HTML with jQuery.
    var target = document.getElementById( "target" );
    $( target ).html( "<td>Hello <b>World</b>!</td>" );

**Удобство.** Есть также много распространенных вариантов использования DOM-манипуляций, которые неудобно выполнять с помощью чистых DOM-методов. Например, для вставки элемента, хранящегося в `newElement`, после `target` элемента требуется довольно подробный метод DOM:

    // Inserting a new element after another with the native DOM API.
    var target = document.getElementById( "target" );
    var newElement = document.createElement( "div" );
    target.parentNode.insertBefore( newElement, target.nextSibling );

Оборачивая `target` элемент в объект jQuery, та же задача становится намного проще:

    // Inserting a new element after another with jQuery.
    var target = document.getElementById( "target" );
    var newElement = document.createElement( "div" );
    $( target ).after( newElement );

По большей части эти детали - просто ловушки, стоящие между вами и вашими целями.

### Getting Elements Into the jQuery Object
Когда функция jQuery `$()` вызывается с помощью селектора CSS, она возвращает объект jQuery, обертывающий все элементы, соответствующие этому селектору. Например, написав:

    // Selecting all <h1> tags.
    var headings = $( "h1" );

`headings` теперь является элементом jQuery, содержащим все теги `<h1>`, уже имеющиеся на странице. В этом можно убедиться, проверив свойство `.length` у `headings`:

    // Viewing the number of <h1> tags on the page.
    var headings = $( "h1" );
    alert( headings.length );

Если на странице более одного тега `<h1>`, это число будет больше единицы. Если на странице нет тегов `<h1>`, то свойство `.length` будет равно нулю. Проверка свойства `.length` является распространенным способом убедиться, что селектор успешно соответствует одному или нескольким элементам.

Если цель состоит в том, чтобы выбрать только первый элемент заголовка, требуется еще один шаг. Есть несколько способов сделать это, но наиболее простым является функция `.eq()`.

    // Selecting only the first <h1> element on the page (in a jQuery object)
    var headings = $( "h1" );
    var firstHeading = headings.eq( 0 );

Теперь `firstHeading` - это объект jQuery, содержащий только первый элемент `<h1>` на странице. А поскольку `firstHeading` - это объект jQuery, у него есть полезные методы, такие как `.html()` и `.after()`. jQuery также имеет метод с именем `.get()`, который предоставляет связанную функцию. Вместо того, чтобы возвращать элемент DOM, заключенный в jQuery, он возвращает сам элемент DOM.

    // Selecting only the first <h1> element on the page.
    var firstHeadingElem = $( "h1" ).get( 0 );

В качестве альтернативы, поскольку объект jQuery "похож на массив", он поддерживает индексацию массива с помощью квадратных скобок:

    // Selecting only the first <h1> element on the page (alternate approach).
    var firstHeadingElem = $( "h1" )[ 0 ];

В любом случае `firstHeadingElem` содержит собственный элемент DOM. Это означает, что он имеет свойства DOM, такие как `.innerHTML`, и методы, такие как `.appendChild()`, но не методы jQuery, такие как `.html()` или `.after()`. С элементом `firstHeadingElem` работать сложнее, но в некоторых случаях он необходим. Одним из таких примеров является сравнение.

### Not All jQuery Objects are Created ===
Важная деталь, касающаяся этого поведения "обертывания" `$()`, заключается в том, что каждый обернутый объект **уникален**. Это верно, даже если объект был создан с тем же селектором или содержит ссылки на одни и те же элементы DOM.

    // Creating two jQuery objects for the same element.
    var logo1 = $( "#logo" );
    var logo2 = $( "#logo" );

Хотя `logo1` и `logo2` создаются одинаково (и заключают в себе один и тот же элемент DOM), они не являются одним и тем же объектом. Например:

    // Comparing jQuery objects.
    alert( $( "#logo" ) === $( "#logo" ) ); // alerts "false"

Однако оба объекта содержат один и тот же элемент DOM. Метод `.get()` полезен для проверки наличия у двух объектов jQuery одного и того же элемента DOM.

    // Comparing DOM elements.
    var logo1 = $( "#logo" );
    var logo1Elem = logo1.get( 0 );

    var logo2 = $( "#logo" );
    var logo2Elem = logo2.get( 0 );

    alert( logo1Elem === logo2Elem ); // alerts "true"

Многие разработчики добавляют префикс `$` к имени переменных, содержащих объекты jQuery, чтобы различать их. В этой практике нет ничего волшебного - она просто помогает некоторым людям отслеживать, что содержат разные переменные. Предыдущий пример можно переписать, чтобы следовать этому соглашению:

    // Comparing DOM elements (with more readable variable names).
    var $logo1 = $( "#logo" );
    var logo1 = $logo1.get( 0 );
    
    var $logo2 = $( "#logo" );
    var logo2 = $logo2.get( 0 );
    
    alert( logo1 === logo2 ); // alerts "true"

Этот код работает так же, как и в приведенном выше примере, но он более понятен для чтения.

Независимо от используемого соглашения об именах очень важно различать объект jQuery и собственные элементы DOM. Нативные методы и свойства DOM отсутствуют в объекте jQuery, и наоборот. Сообщения об ошибках типа `event.target.closest не является функцией` и `TypeError: Object [object Object] не имеет метода setAttribute` указывают на наличие этой распространенной ошибки.

### jQuery Objects Are Not "Live"
Учитывая объект jQuery со всеми элементами абзаца на странице:

    // Selecting all <p> elements on the page.
    var allParagraphs = $( "p" );

...можно ожидать, что содержимое будет увеличиваться и уменьшаться со временем по мере добавления и удаления элементов `<p>` из документа. Объекты jQuery не ведут себя таким образом. Набор элементов, содержащихся в объекте jQuery, не изменится, если он не будет изменен явно. Это означает, что коллекция не является "живо" - она не обновляется автоматически по мере изменения документа. Если документ мог измениться с момента создания объекта jQuery, коллекцию следует обновить, создав новую. Это может быть так же просто, как повторно запустить тот же селектор:

    // Updating the selection.
    allParagraphs = $( "p" );

### Wrapping Up
Хотя элементы DOM предоставляют всю функциональность, необходимую для создания интерактивных веб-страниц, работать с ними может быть непросто. Объект jQuery оборачивает эти элементы, чтобы сгладить этот опыт и упростить общие задачи. При создании или выборе элементов с помощью jQuery результат всегда будет заключен в новый объект jQuery. Если ситуация требует нативных элементов DOM, к ним можно получить доступ через метод .get() и/или подписку в стиле массива.

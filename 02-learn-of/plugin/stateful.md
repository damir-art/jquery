# Writing Stateful Plugins with the jQuery UI Widget Factory
В то время как большинство существующих подключаемых модулей jQuery не имеют состояния, то есть мы вызываем их для элемента, и это степень нашего взаимодействия с подключаемым модулем, существует большой набор функций, которые не вписываются в базовый шаблон подключаемого модуля.

Чтобы восполнить этот пробел, в jQuery UI реализована более продвинутая система плагинов. Новая система управляет состоянием, позволяет отображать несколько функций с помощью одного плагина и предоставляет различные точки расширения. Эта система называется фабрикой виджетов и представлена как `jQuery.widget` как часть jQuery UI 1.8, однако его можно использовать независимо от jQuery UI.

Чтобы продемонстрировать возможности фабрики виджетов, мы создадим простой плагин индикатора выполнения.

Для начала мы создадим индикатор выполнения, который позволит нам установить прогресс только один раз. Как мы видим ниже, это делается путем вызова `jQuery.widget` с двумя параметрами: именем создаваемого плагина и литералом объекта, содержащим функции для поддержки нашего плагина.

Когда наш плагин будет вызван, он создаст новый экземпляр плагина, и все функции будут выполняться в контексте этого экземпляра. Он отличается от стандартного плагина jQuery двумя важными моментами. Во-первых, контекст - это объект, а не элемент DOM. Во-вторых, контекст всегда представляет собой один объект, а не коллекцию.

Простой плагин с отслеживанием состояния, использующий jQuery UI Widget Factory:

    $.widget( "nmk.progressbar", {
      _create: function() {
        var progress = this.options.value + "%";
        this.element.addClass( "progressbar" ).text( progress );
      }
    });

Имя плагина должно содержать пространство имен; в данном случае мы использовали пространство имен `nmk`. Существует ограничение, что пространства имен должны быть ровно на один уровень в глубину, то есть мы не можем использовать пространство имен, подобное `nmk.foo`. Мы также видим, что фабрика виджетов предоставила нам два свойства. `this.element` - это объект jQuery, содержащий ровно один элемент. Если наш плагин вызывается для объекта jQuery, содержащего несколько элементов, для каждого элемента будет создан отдельный экземпляр плагина, и каждый экземпляр будет иметь свой `this.element`. Второе свойство, `this.options`, представляет собой хэш, содержащий пары ключ/значение для всех параметров нашего плагина. Эти параметры можно передать нашему плагину, как показано здесь.

*Примечание.* В нашем примере мы используем пространство имен `nmk`. Пространство имен `ui` зарезервировано для официальных подключаемых модулей пользовательского интерфейса jQuery. При создании собственных плагинов вы должны создать собственное пространство имен. Это дает понять, откуда взялся плагин и является ли он частью более крупной коллекции.

Передача опций виджету:

    $( "<div />" ).appendTo( "body" ).progressbar({ value: 20 });

Когда мы вызываем `jQuery.widget`, он расширяет jQuery, добавляя метод в `jQuery.fn` (так же, как мы создаем стандартный плагин). Имя добавляемой функции основано на имени, которое вы передаете `jQuery.widget`, без пространства имен; в нашем случае это создаст `jQuery.fn.progressbar`. Параметры, передаваемые нашему плагину, устанавливаются в `this.options` внутри экземпляра нашего плагина.

Как показано ниже, мы можем указать значения по умолчанию для любого из наших параметров. При разработке своего API вы должны выяснить наиболее распространенный вариант использования вашего плагина, чтобы вы могли установить соответствующие значения по умолчанию и сделать все параметры действительно необязательными.

Установка параметров по умолчанию для виджета:

    $.widget( "nmk.progressbar", {
      // Default options.
      options: {
        value: 0
      },
      _create: function() {
        var progress = this.options.value + "%";
        this.element.addClass( "progressbar" ).text( progress );
      }
    });

## Adding Methods to a Widget
Теперь, когда мы можем инициализировать наш индикатор выполнения, мы добавим возможность выполнять действия, вызывая методы в нашем экземпляре плагина. Чтобы определить метод плагина, мы просто включаем функцию в литерал объекта, который мы передаем в `jQuery.widget`. Мы также можем определить «приватные» методы, добавив подчеркивание перед именем функции.

Создание методов виджета:

    $.widget( "nmk.progressbar", {
      options: {
        value: 0
      },
      _create: function() {
        var progress = this.options.value + "%";
        this.element.addClass("progressbar").text( progress );
      },
      // Create a public method.
      value: function( value ) {
        // No value passed, act as a getter.
        if ( value === undefined ) {
          return this.options.value;
        // Value passed, act as a setter.
        } else {
          this.options.value = this._constrain( value );
          var progress = this.options.value + "%";
          this.element.text( progress );
        }
      },
  
      // Create a private method.
      _constrain: function( value ) {
        if ( value > 100 ) {
          value = 100;
        }
        if ( value < 0 ) {
          value = 0;
        }
        return value;
      }
    });

Чтобы вызвать метод экземпляра плагина, вы передаете имя метода плагину jQuery. Если вы вызываете метод, который принимает параметры, вы просто передаете эти параметры после имени метода.

Вызов методов экземпляра плагина:

    var bar = $( "<div />" ).appendTo( "body").progressbar({ value: 20 });
    
    // Get the current value.
    alert( bar.progressbar( "value" ) );
    
    // Update the value.
    bar.progressbar( "value", 50 );
    
    // Get the current value again.
    alert( bar.progressbar( "value" ) );

*Примечание.* Выполнение методов путем передачи имени метода той же функции jQuery, которая использовалась для инициализации подключаемого модуля, может показаться странным. Это сделано для предотвращения загрязнения пространства имен jQuery при сохранении возможности связывания вызовов методов.

## Working with Widget Options
Один из методов, который автоматически доступен для нашего плагина, - это метод **option**. Метод option позволяет получить и установить параметры после инициализации. Этот метод работает точно так же, как методы jQuery `.css()` и `.attr()`: вы можете передать только имя, чтобы использовать его в качестве геттера, имя и значение, чтобы использовать его в качестве одиночного сеттера, или хэш пар имя/значение, для установки нескольких значений. При использовании в качестве геттера плагин вернет текущее значение параметра, которое соответствует переданному имени. При использовании в качестве установщика метод плагина `_setOption` будет вызываться для каждого устанавливаемого параметра. Мы можем указать метод `_setOption` в нашем плагине, чтобы реагировать на изменения параметров.

Ответ, когда опция установлена:

    $.widget( "nmk.progressbar", {
        options: {
          value: 0
        },
        _create: function() {
          this.element.addClass( "progressbar" );
          this._update();
        },
        _setOption: function( key, value ) {
          this.options[ key ] = value;
          this._update();
        },
        _update: function() {
          var progress = this.options.value + "%";
          this.element.text( progress );
        }
    });

## Adding Callbacks
Один из самых простых способов сделать ваш плагин расширяемым - добавить обратные вызовы, чтобы пользователи могли реагировать на изменение состояния вашего плагина. Ниже мы можем увидеть, как добавить обратный вызов в наш индикатор выполнения, чтобы указать, когда прогресс достиг 100%. Метод `_trigger` принимает три параметра: имя обратного вызова, собственный объект события, который инициировал обратный вызов, и хэш данных, относящихся к событию. Имя обратного вызова - единственный обязательный параметр, но другие могут быть очень полезны для пользователей, которые хотят реализовать пользовательские функции поверх вашего плагина. Например, если бы мы создавали плагин с возможностью перетаскивания, мы могли бы передать собственное событие `mousemove` при запуске обратного вызова перетаскивания; это позволит пользователям реагировать на перетаскивание на основе координат `x/y`, предоставленных объектом события.

Предоставление обратных вызовов для расширения пользователя:

    $.widget( "nmk.progressbar", {
      options: {
        value: 0
      },
      _create: function() {
        this.element.addClass( "progressbar" );
        this._update();
      },
      _setOption: function( key, value ) {
        this.options[ key ] = value;
        this._update();
      },
      _update: function() {
        var progress = this.options.value + "%";
        this.element.text( progress );
        if ( this.options.value == 100 ) {
          this._trigger( "complete", null, { value: 100 } );
        }
      }
    });

Функции обратного вызова - это, по сути, просто дополнительные параметры, поэтому вы можете получить и установить их так же, как и любой другой параметр. Всякий раз, когда выполняется обратный вызов, также запускается соответствующее событие. Тип события определяется объединением имени плагина и имени обратного вызова. Обратный вызов и событие получают одни и те же два параметра: объект события и хэш данных, относящихся к событию, как мы увидим ниже.

Если у вашего плагина есть функции, которые вы хотите запретить пользователю, лучший способ поддержать это - создать отменяемые обратные вызовы. Пользователи могут отменить обратный вызов или связанное с ним событие так же, как они отменяют любое собственное событие: вызвав `event.preventDefault()` или используя `return false`. Если пользователь отменит обратный вызов, метод `_trigger` вернет `false`, чтобы вы могли реализовать соответствующую функциональность в своем плагине.

Привязка к событиям виджета:

    var bar = $( "<div />" ).appendTo( "body" ).progressbar({
      complete: function( event, data ) {
        alert( "Callbacks are great!" );
      }
    }).bind( "progressbarcomplete", function( event, data ) {
      alert( "Events bubble and support many handlers for extreme flexibility." );
      alert( "The progress bar value is " + data.value );
    });
    bar.progressbar( "option", "value", 100 );

## Фабрика виджетов: под капотом
Когда вы вызываете `jQuery.widget`, он создает функцию-конструктор для вашего плагина и устанавливает литерал объекта, который вы передаете, в качестве прототипа для экземпляров вашего плагина. Все функциональные возможности, которые автоматически добавляются в ваш плагин, исходят из базового прототипа виджета, который определяется как `jQuery.Widget.prototype`. Когда экземпляр подключаемого модуля создается, он сохраняется в исходном элементе DOM с использованием `jQuery.data` с полным именем подключаемого модуля (пространство имен подключаемого модуля, плюс дефис, а также имя подключаемого модуля) в качестве ключа. Например, виджет диалога пользовательского интерфейса jQuery использует ключ `ui-dialog`.

Поскольку экземпляр плагина напрямую связан с элементом DOM, вы можете получить доступ к экземпляру плагина напрямую, вместо того, чтобы использовать открытый метод плагина, если хотите. Это позволит вам вызывать методы непосредственно в экземпляре плагина вместо передачи имен методов в виде строк, а также даст вам прямой доступ к свойствам плагина.

    var bar = $( "<div />")
      .appendTo( "body" )
      .progressbar()
      .data( "nmk-progressbar" );

    // Call a method directly on the plugin instance.
    bar.option( "value", 50 );

    // Access properties on the plugin instance.
    alert( bar.options.value );

Одним из самых больших преимуществ наличия конструктора и прототипа для плагина является простота расширения плагина. Добавляя или изменяя методы в прототипе плагина, мы можем изменить поведение всех экземпляров нашего плагина. Например, если бы мы хотели добавить метод в наш индикатор выполнения, чтобы сбросить прогресс до 0%, мы могли бы добавить этот метод в прототип, и он был бы мгновенно доступен для вызова в любом экземпляре плагина.

    $.nmk.progressbar.prototype.reset = function() {
      this._setOption( "value", 0 );
    };

## Cleaning Up
В некоторых случаях имеет смысл разрешить пользователям применять, а затем отменить применение вашего плагина. Вы можете сделать это с помощью метода `_destroy`. В методе `_destroy` вы должны отменить все, что ваш плагин мог сделать во время инициализации или последующего использования. Метод `_destroy` вызывается автоматически, если элемент, к которому привязан ваш экземпляр плагина, удаляется из DOM, поэтому его также можно использовать для сборки мусора. Базовый метод уничтожения вызывает `_destroy` для экземпляра плагина.

Добавление метода уничтожения, в виджет:

    $.widget( "nmk.progressbar", {
      options: {
        value: 0
      },
      _create: function() {
        this.element.addClass("progressbar");
        this._update();
      },
      _setOption: function( key, value ) {
        this.options[ key ] = value;
        this._update();
      },
      _update: function() {
        var progress = this.options.value + "%";
        this.element.text( progress );
        if ( this.options.value === 100 ) {
          this._trigger( "complete", null, { value: 100 } );
        }
      },
      _destroy: function() {
        this.element
          .removeClass( "progressbar" )
          .text( "" );
      }
    });

## Conclusion
**Widget Factory** - это только один из способов создания плагинов с отслеживанием состояния. Есть несколько различных моделей, которые можно использовать, и каждая из них имеет свои преимущества и недостатки. Фабрика виджетов решает за вас множество распространенных проблем и может значительно повысить производительность, а также значительно улучшает повторное использование кода, что делает ее отлично подходящей для пользовательского интерфейса jQuery, а также для многих других плагинов с отслеживанием состояния.

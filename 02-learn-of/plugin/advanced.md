# Advanced Plugin Concepts

## Provide Public Access to Default Plugin Settings
Улучшение, которое мы можем и должны внести в приведенный выше код, состоит в том, чтобы открыть настройки плагина по умолчанию. Это важно, потому что пользователям плагинов очень легко переопределить/настроить плагин с минимальным кодом. И здесь мы начинаем использовать функцию объекта.

    // Определение плагина
    $.fn.hilight = function( options ) {
      // Расширьте наши параметры по умолчанию с помощью предоставленных.
      // Обратите внимание, что первый аргумент для расширения является пустым.
      // object - это сделано для того, чтобы не переопределить наш объект «по умолчанию».
      var opts = $.extend( {}, $.fn.hilight.defaults, options );

      // Здесь находится код реализации нашего плагина.

    };

    // Настройки плагина по умолчанию - добавлены как свойство в функцию нашего плагина.
    $.fn.hilight.defaults = {
      foreground: "red",
      background: "yellow"
    };

Теперь пользователи могут включать в свои скрипты такую строку:

    // Это нужно вызывать только один раз и не нужно вызывать из «готового» блока.
    $.fn.hilight.defaults.foreground = "blue";

И теперь мы можем вызвать метод плагина следующим образом, и он будет использовать синий цвет переднего плана:

    $( "#myDiv" ).hilight();

Как видите, мы позволили пользователю написать одну строку кода, чтобы изменить цвет переднего плана плагина по умолчанию. И пользователи по-прежнему могут выборочно переопределять это новое значение по умолчанию, когда захотят:

    // Переопределить цвет переднего плана плагина по умолчанию.
    $.fn.hilight.defaults.foreground = "blue";
    
    // ...
    
    // Вызвать плагин, используя новые значения по умолчанию.
    $( ".hilightDiv" ).hilight();
    
    // ...
    
    // Переопределить значение по умолчанию, передав параметры методу плагина.
    $( "#green" ).hilight({
        foreground: "green"
    });

## Provide Public Access to Secondary Functions as Applicable
Этот пункт идет рука об руку с предыдущим пунктом и представляет собой интересный способ расширить ваш плагин (и позволить другим расширить ваш плагин). Например, в реализации нашего плагина может быть определена функция под названием «формат», которая форматирует выделенный текст. Наш плагин теперь может выглядеть так, с реализацией по умолчанию метода форматирования, определенного ниже функции подсветки:

    // Определение плагина.
    $.fn.hilight = function( options ) {
      // Повторить и переформатировать каждый соответствующий элемент.
      return this.each(function() {
        var elem = $( this );
        // ...
        var markup = elem.html();
        // Call our format function.
        markup = $.fn.hilight.format( markup );
        elem.html( markup );
      });
    };
    
    // Define our format function.
    $.fn.hilight.format = function( txt ) {
      return "<strong>" + txt + "</strong>";
    };

Мы могли бы так же легко поддерживать другое свойство объекта параметров, которое позволяло бы предоставлять функцию обратного вызова для переопределения форматирования по умолчанию. Это еще один отличный способ поддержки настройки вашего плагина. Показанная здесь техника делает еще один шаг вперед, фактически раскрывая функцию форматирования, чтобы ее можно было переопределить. С помощью этой техники другие могли бы выпускать свои собственные переопределения вашего плагина - другими словами, это означает, что другие могут писать плагины для вашего плагина.

Принимая во внимание тривиальный пример плагина, который мы создаем в этой статье, вам может быть интересно, когда он когда-либо будет полезен. Одним из реальных примеров является плагин Cycle. Плагин Cycle - это плагин для слайд-шоу, который поддерживает ряд встроенных эффектов перехода - прокрутку, слайд, затухание и т. д. Но на самом деле нет способа определить каждый отдельный тип эффекта, который можно применить к переходу между слайдами. И именно здесь этот тип расширяемости полезен. Плагин Cycle предоставляет объект «переходов», к которому пользователи могут добавлять свои собственные определения переходов. В плагине это определяется так:

    $.fn.cycle.transitions = {
      // ...
    };

Этот метод позволяет другим определять и отправлять определения переходов, которые подключаются к подключаемому модулю цикла.

## Keep Private Functions Private
Техника раскрытия части вашего плагина для переопределения может быть очень мощной. Но вам нужно тщательно подумать о том, какие части вашей реализации выставлять напоказ. После его раскрытия вам нужно помнить, что любые изменения в вызывающих аргументах или семантике могут нарушить обратную совместимость. Как правило, если вы не уверены, следует ли предоставлять доступ к конкретной функции, то, вероятно, не стоит этого делать.

Так как же нам определить больше функций, не загромождая пространство имен и не раскрывая реализацию? Это работа для замыкания. Для демонстрации мы добавим в наш плагин еще одну функцию под названием «отладка». Функция отладки будет регистрировать количество выбранных элементов в консоли. Чтобы создать замыкание, мы заключаем все определение подключаемого модуля в функцию (как подробно описано в Руководстве по разработке jQuery).

    // Create closure.
    (function( $ ) {
      // Plugin definition.
      $.fn.hilight = function( options ) {
        debug( this );
        // ...
      };

      // Private function for debugging.
      function debug( obj ) {
        if ( window.console && window.console.log ) {
          window.console.log( "hilight selection count: " + obj.length );
        }
      };
      // ...
    // End of closure.
    })( jQuery );

К нашему методу «отладки» нельзя получить доступ извне замыкания, и поэтому он является закрытым для нашей реализации.

## Bob and Sue
Допустим, Боб создал новый плагин галереи *(под названием «superGallery»)*, который берет список изображений и делает их доступными для навигации. Боб добавил анимацию, чтобы было интереснее. Он попытался сделать плагин максимально настраиваемым, и в итоге получилось что-то вроде этого:

    jQuery.fn.superGallery = function( options ) {
      // Bob's default settings:
      var defaults = {
        textColor: "#000",
        backgroundColor: "#fff",
        fontSize: "1em",
        delay: "quite long",
        getTextFromTitle: true,
        getTextFromRel: false,
        getTextFromAlt: false,
        animateWidth: true,
        animateOpacity: true,
        animateHeight: true,
        animationDuration: 500,
        clickImgToGoToNext: true,
        clickImgToGoToLast: false,
        nextButtonText: "next",
        previousButtonText: "previous",
        nextButtonTextColor: "red",
        previousButtonTextColor: "red"
      };

      var settings = $.extend( {}, defaults, options );
      return this.each(function() {
        // Plugin code would go here...
      });
    };

Первое, что, вероятно, приходит вам на ум (хорошо, может быть, не первое), это перспектива того, насколько огромным должен быть этот плагин для такого уровня настройки. Плагин, если бы он не был вымышленным, вероятно, был бы намного больше, чем необходимо. Есть только столько килобайт, которые люди готовы потратить!

Теперь наш друг Боб думает, что все в порядке; на самом деле, он очень впечатлен плагином и уровнем его настройки. Он считает, что все варианты делают решение более универсальным, которое можно использовать в самых разных ситуациях.

Сью, еще один наш друг, решила использовать этот новый плагин. Она настроила все необходимые параметры, и теперь перед ней лежит работающее решение. Только через пять минут, поиграв с плагином, она понимает, что галерея выглядела бы намного лучше, если бы ширина каждого изображения анимировалась с меньшей скоростью. Она торопливо просматривает документацию Боба, но не находит опции `animateWidthDuration`!

## Do You See The Problem?
Дело не в том, сколько опций есть у вашего плагина, а в том какие у него возможности!

Боб немного переборщил. Уровень настройки, который он предлагает, хотя и может показаться высоким, на самом деле довольно низок, особенно учитывая все возможные вещи, которые можно контролировать при использовании этого плагина. Боб совершил ошибку, предложив множество смехотворно специфичных опций, из-за чего его плагин стало намного сложнее настраивать!

## A Better Model
Так что это довольно очевидно: Бобу нужна новая модель настройки, которая не отказывается от контроля и не абстрагирует необходимые детали.

Причина, по которой Боба так привлекает эта высокоуровневая простота, заключается в том, что фреймворк jQuery очень подходит для такого мышления. Предлагать опцию `previousButtonTextColor` приятно и просто, но давайте посмотрим правде в глаза, подавляющее большинство пользователей плагинов захотят получить больше контроля!

Вот несколько советов, которые помогут вам создать лучший набор настраиваемых параметров для ваших плагинов.

### Don't Create Plugin-specific Syntax
Разработчикам, использующим ваш плагин, не нужно изучать новый язык или терминологию только для того, чтобы выполнить свою работу.

Боб думал, что предлагает максимальную настройку с помощью опции `delay` (см. выше). Он сделал так, что с помощью его плагина вы можете указать четыре разных задержки: «очень короткая», «довольно короткая», «довольно длинная», «очень длинная»:

    var delayDuration = 0;
    switch ( settings.delay ) {
      case "very short":
        delayDuration = 100;
        break;
      case "quite short":
        delayDuration = 200;
        break;
      case "quite long":
        delayDuration = 300;
        break;
      case "very long":
        delayDuration = 400;
        break;
      default:
        delayDuration = 200;
    }

Это не только ограничивает уровень контроля людей, но и занимает довольно много места. Двенадцать строк кода только для определения времени задержки - это многовато, вам не кажется? Лучшим способом создания этой опции было бы позволить пользователям плагина указать количество времени (в миллисекундах) в виде числа, чтобы не требовалось никакой обработки опции.

Ключевым моментом здесь является не снижение уровня контроля за счет вашей абстракции. Ваша абстракция, какой бы она ни была, может быть настолько упрощенной, насколько вы хотите, но убедитесь, что люди, которые используют ваш плагин, по-прежнему будут иметь столь востребованный низкоуровневый контроль! (Под низким уровнем я подразумеваю неабстрагированный.)

### Give Full Control of Elements
Если ваш плагин создает элементы, которые будут использоваться в DOM, хорошей идеей будет предложить пользователям плагина какой-то способ доступа к этим элементам. Иногда это означает предоставление идентификаторов или классов определенных элементов. Но обратите внимание, что ваш плагин не должен полагаться на эти хуки внутри:

Плохая реализация:

    // Plugin code
    $( "<div class='gallery-wrapper' />" ).appendTo( "body" );
    $( ".gallery-wrapper" ).append( "..." );

Чтобы позволить пользователям получать доступ к этой информации и даже манипулировать ею, вы можете сохранить ее в переменной, содержащей настройки вашего плагина. Лучшая реализация предыдущего кода показана ниже:

    // Retain an internal reference:
    var wrapper = $( "<div />" )
        .attr( settings.wrapperAttrs )
        .appendTo( settings.container );
    
    // Easy to reference later...
    wrapper.append( "..." );

Обратите внимание, что мы создали ссылку на внедренную оболочку, а также вызываем метод `.attr()` для добавления любых указанных атрибутов к элементу. Итак, в наших настройках это может быть обработано так:

    var defaults = {
      wrapperAttrs : {
        class: "gallery-wrapper"
      },
      // ... rest of settings ...
    };
    
    // We can use the extend method to merge options/settings as usual:
    // But with the added first parameter of TRUE to signify a DEEP COPY:
    var settings = $.extend( true, {}, defaults, options );

Метод $.extend() теперь будет рекурсивно проходить по всем вложенным объектам, чтобы дать нам объединенную версию как значений по умолчанию, так и переданных параметров, отдавая приоритет переданным параметрам.

Пользователь плагина теперь имеет право указать любой атрибут этого элемента-оболочки, поэтому, если ему требуется, чтобы был хук для любых стилей CSS, он может довольно легко добавить класс или изменить имя идентификатора без необходимости копаться в исходник плагина.

Эту же модель можно использовать, чтобы позволить пользователю определять стили CSS:

    var defaults = {
      wrapperCSS: {},
      // ... rest of settings ...
    };

    // Later on in the plugin where we define the wrapper:
    var wrapper = $( "<div />" )
      .attr( settings.wrapperAttrs )
      .css( settings.wrapperCSS ) // ** Set CSS!
      .appendTo( settings.container );

Ваш плагин может иметь связанную таблицу стилей, в которую разработчики могут добавлять стили CSS. Даже в этой ситуации хорошей идеей будет предложить какой-нибудь удобный способ установки стилей в JavaScript без использования селектора для доступа к элементам.

### Provide Callback Capabilities
Что такое обратный вызов? - Обратный вызов - это, по сути, функция, которая вызывается позже и обычно вызывается событием. Он передается в качестве аргумента, обычно при инициирующем вызове компонента, в данном случае подключаемого модуля jQuery.

Если ваш плагин управляется событиями, было бы неплохо предоставить возможность обратного вызова для каждого события. Кроме того, вы можете создавать свои собственные пользовательские события, а затем предоставлять для них обратные вызовы. В этом плагине галереи может иметь смысл добавить обратный вызов `onImageShow`.

    var defaults = {
      // We define an empty anonymous function so that
      // we don't need to check its existence before calling it.
      onImageShow : function() {},
      // ... rest of settings ...
    };
    
    // Later on in the plugin:
    nextButton.on( "click", showNextImage );
    function showNextImage() {
      // Returns reference to the next image node
      var image = getNextImage();
      // Stuff to show the image here...
      // Here's the callback:
      settings.onImageShow.call( image );
    }

Вместо того, чтобы инициировать обратный вызов традиционными средствами (добавляя круглые скобки), мы вызываем его в контексте `image`, которое будет ссылкой на узел изображения. Это означает, что у вас есть доступ к фактическому узлу изображения через ключевое слово `this` в обратном вызове:

    $( "ul.imgs li" ).superGallery({
      onImageShow: function() {
        $( this ).after( "<span>" + $( this ).attr( "longdesc" ) + "</span>" );
      },
      // ... other options ...
    });

Точно так же вы можете добавить обратный вызов `onImageHide` и множество других. Смысл обратных вызовов в том, чтобы дать пользователям плагинов простой способ добавить дополнительную функциональность, не копаясь в исходниках.

### Remember, It's a Compromise
Ваш плагин не сможет работать в любой ситуации. И точно так же не будет очень полезно, если вы не предложите никаких методов контроля или предложите очень мало. Так что помните, это всегда будет компромисс. Три вещи, которые вы всегда должны учитывать:

- **Гибкость:** со сколькими ситуациями сможет справиться ваш плагин?
- **Размер:** соответствует ли размер вашего плагина уровню его функциональности? т.е. Вы бы использовали очень простой плагин всплывающей подсказки, если бы он был размером 20 КБ? - Возможно нет!
- **Производительность:** сильно ли ваш плагин обрабатывает параметры? Влияет ли это на скорость? Стоят ли накладные расходы конечного пользователя?

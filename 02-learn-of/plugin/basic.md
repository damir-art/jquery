# How to Create a Basic Plugin
Иногда вы хотите сделать часть функциональности доступной во всем коде. Например, возможно, вам нужен один метод, который вы можете вызывать для выбора jQuery, который выполняет ряд операций над выбором. В этом случае вы можете написать плагин.

## How jQuery Works 101: jQuery Object Methods
Прежде чем мы напишем наши собственные плагины, мы должны сначала немного понять, как работает jQuery. Взгляните на этот код:

    $( "a" ).css( "color", "red" );

Это довольно простой код jQuery, но знаете ли вы, что происходит за кулисами? Всякий раз, когда вы используете функцию `$` для выбора элементов, она возвращает объект jQuery. Этот объект содержит все используемые вами методы: `.css()`, `.click()` и т. д. и все элементы, соответствующие вашему селектору. Объект jQuery получает эти методы из объекта `$.fn`. Этот объект содержит все методы объекта jQuery, и если мы хотим написать свои собственные методы, он также должен их содержать.

## Basic Plugin Authoring
Допустим, мы хотим создать плагин, который делает текст в наборе извлеченных элементов зеленым. Все, что нам нужно сделать, это добавить функцию `greenify` в `$.fn`, и она будет доступна, как и любой другой объектный метод jQuery.

    $.fn.greenify = function() {
      this.css( "color", "green" );
    };

    $( "a" ).greenify(); // делает все ссылки зелеными

Обратите внимание, что для использования другого метода `.css()` мы используем `this`, а не `$(this)`. Это потому, что наша функция `greenify` является частью того же объекта, что и `.css()`.

## Chaining
Это работает, но есть пара вещей, которые нам нужно сделать, чтобы наш плагин выжил в реальном мире. Одной из возможностей jQuery является цепочка, когда вы связываете пять или шесть действий с одним селектором. Это достигается за счет того, что все методы объекта jQuery снова возвращают исходный объект jQuery (есть несколько исключений: `.width()`, вызываемый без параметров, возвращает ширину выбранного элемента и не является цепочкой). Чтобы сделать наш метод подключаемым к цепочке, требуется всего одна строка кода:

    $.fn.greenify = function() {
      this.css( "color", "green" );
      return this;
    }
    
    $( "a" ).greenify().addClass( "greenified" );

## Protecting the $ Alias and Adding Scope
https://benalman.com/news/2010/11/immediately-invoked-function-expression/

Переменная `$` очень популярна среди библиотек JavaScript, и если вы используете другую библиотеку с jQuery, вам придется сделать так, чтобы jQuery не использовал `$` с `jQuery.noConflict()`. Однако это сломает наш плагин, поскольку он написан с предположением, что `$` является псевдонимом функции jQuery. Чтобы хорошо работать с другими плагинами и по-прежнему использовать псевдоним `jQuery` `$`, нам нужно поместить весь наш код в выражение немедленно вызываемой функции IIFE, а затем передать функцию jQuery и назвать параметр `$`:

    (function ( $ ) {
      $.fn.greenify = function() {
        this.css( "color", "green" );
        return this;
      };
    }( jQuery ));

Кроме того, основная цель функции с немедленным вызовом - позволить нам иметь собственные приватные переменные. Представьте, что нам нужен другой зеленый цвет, и мы хотим сохранить его в переменной.

    (function ( $ ) {
    
        var shade = "#556b2f";
    
        $.fn.greenify = function() {
            this.css( "color", shade );
            return this;
        };
    
    }( jQuery ));

## Minimizing Plugin Footprint
Хорошей практикой при написании плагинов является использование только одного слота в `$.fn`. Это снижает как вероятность того, что ваш плагин будет переопределен, так и вероятность того, что ваш плагин переопределит другие плагины. Другими словами, это плохо:

    (function( $ ) {
      $.fn.openPopup = function() {
        // Open popup code.
      };
      $.fn.closePopup = function() {
        // Close popup code.
      };
    }( jQuery ));

Было бы намного лучше иметь один слот и использовать параметры для управления тем, какое действие выполняет этот слот.

    (function( $ ) {
      $.fn.popup = function( action ) {
        if ( action === "open") {
          // Open popup code.
        }
        if ( action === "close" ) {
          // Close popup code.
        }
      };
    }( jQuery ));

## Using the each() Method
Ваш типичный объект jQuery будет содержать ссылки на любое количество элементов DOM, поэтому объекты jQuery часто называют коллекциями. Если вы хотите выполнить какие-либо манипуляции с определенными элементами (например, получить data-атрибут, вычислить определенные позиции), вам нужно использовать `.each()` для перебора элементов.

    $.fn.myNewPlugin = function() {
        return this.each(function() {
          // Сделайте что-нибудь с каждым элементом здесь.
        });
    };

Обратите внимание, что мы возвращаем результаты `.each()` вместо `this`. Поскольку `.each()` уже поддерживает цепочку, он возвращает `this`, которое мы затем возвращаем. Это лучший способ поддерживать цепочку, чем то, что мы делали до сих пор.

## Accepting Options
Поскольку ваши плагины становятся все более и более сложными, хорошей идеей будет сделать ваш плагин настраиваемым, приняв параметры. Проще всего это сделать, особенно если вариантов много, с помощью литерала объекта. Давайте изменим наш плагин **greenify**, чтобы он принимал некоторые параметры.

    function ( $ ) {
      $.fn.greenify = function( options ) {

        // This is the easiest way to have default options.
        var settings = $.extend({
          // These are the defaults.
          color: "#556b2f",
          backgroundColor: "white"
        }, options );

        // Greenify the collection based on the settings variable.
        return this.css({
          color: settings.color,
          backgroundColor: settings.backgroundColor
        });

      };
    }( jQuery ));

Пример использования:

    $( "div" ).greenify({
      color: "orange"
    });

Значение по умолчанию `#556b2f` для `color` переопределяется функцией `$.extend()` и становится оранжевым.

## Putting It Together
Вот пример небольшого плагина, использующего некоторые из методов, которые мы обсуждали:

    (function( $ ) {
      $.fn.showLinkLocation = function() {
        this.filter( "a" ).each(function() {
          var link = $( this );
          link.append( " (" + link.attr( "href" ) + ")" );
        });
        return this;
      };
    }( jQuery ));

    // Usage example:
    $( "a" ).showLinkLocation();

Этот плагин просматривает все якоря в коллекции и добавляет атрибут href в круглых скобках.

    <!-- Before plugin is called: -->
    <a href="page.html">Foo</a>

    <!-- After plugin is called: -->
    <a href="page.html">Foo (page.html)</a>

Однако наш плагин можно оптимизировать:

    (function( $ ) {
      $.fn.showLinkLocation = function() {
        this.filter( "a" ).append(function() {
          return " (" + this.href + ")";
        });
        return this;
      };
    }( jQuery ));

Мы используем возможность метода `.append()` принимать обратный вызов, и возвращаемое значение этого обратного вызова будет определять, что добавляется к каждому элементу в коллекции. Обратите также внимание, что мы не используем метод `.attr()` для получения атрибута `href`, потому что собственный API DOM предоставляет нам легкий доступ с помощью свойства `href` с соответствующим названием.

# Manipulating Elements
Полную документацию по методам манипулирования jQuery см. в документации по манипулированию на сайте api.jquery.com: https://api.jquery.com/category/manipulation/

## Getting and Setting Information About Elements
Есть много способов изменить существующий элемент. Среди наиболее распространенных задач - изменение внутреннего HTML или атрибута элемента. jQuery предлагает простые кросс-браузерные методы для подобных манипуляций. Вы также можете получить информацию об элементах, используя многие из тех же методов в их воплощениях геттера. Дополнительные сведения о геттерах и сеттерах см. в разделе "Working with Selections". Вот несколько методов, которые вы можете использовать для получения и установки информации об элементах:

- `.html()` - получить или установить HTML-содержимое
- `.text()` - получить или установить текстовое содержимое; HTML-код будет виден
- `.attr()` - получить или установить значение предоставленного атрибута
- `.width()` - получить или задать ширину в пикселях первого элемента выборки как целое число
- `.height()` - получить или задайть высоту в пикселях первого элемента выборки как целое число
- `.val()` - получить или установить значение элементов формы
- `.position()` - получить объект с информацией о позиции для первого элемента выборки относительно его первого позиционированного предка. *Может быть только геттером*.

Изменение вещей в элементах тривиально, но помните, что изменение повлияет на все элементы выборки. Если вы просто хотите изменить один элемент, обязательно укажите это в выборке перед вызовом метода setter.

    // Changing the HTML of an element.
    $( "#myDiv p:first" ).html( "New <strong>first</strong> paragraph!" );

## Moving, Copying, and Removing Elements
Хотя существует множество способов перемещения элементов по DOM, обычно есть два подхода:
- Поместите выбранный элемент(ы) относительно другого элемента.
- Поместите элемент относительно выбранного элемента (элементов).

Например, jQuery предоставляет `.insertAfter()` и `.after()`. Метод `.insertAfter()` помещает выбранные элементы после элемента, предоставленного в качестве аргумента. Метод `.after()` помещает элемент, предоставленный в качестве аргумента, после выбранного элемента. Несколько других методов следуют этому шаблону: `.insertBefore()` и `.before()`, `.appendTo()` и `.append()`, а также `.prependTo()` и `.prepend()`.

Наиболее целесообразный метод будет зависеть от того, какие элементы выбраны и нужно ли вам сохранять ссылку на элементы, которые вы добавляете на страницу. Если вам нужно сохранить ссылку, вы всегда будете использовать первый подход - размещение выбранных элементов относительно другого элемента - поскольку он возвращает размещаемые вами элементы. В этом случае предпочтительными инструментами должны быть `.insertAfter()`, `.insertBefore()`, `.appendTo()` и `.prependTo()`.

    // Moving elements using different approaches.
    
    // Make the first list item the last list item:
    var li = $( "#myList li:first" ).appendTo( "#myList" );
    
    // Another approach to the same problem:
    $( "#myList" ).append( $( "#myList li:first" ) );
    
    // Note that there's no way to access the list item
    // that we moved, as this returns the list itself.

## Cloning Elements
Такие методы, как `.appendTo()`, перемещают элемент, но иногда вместо этого требуется копия элемента. В этом случае сначала используйте `.clone()`:

    // Making a copy of an element.

    // Copy the first list item to the end of the list:
    $( "#myList li:first" ).clone().appendTo( "#myList" );

Если вам нужно скопировать связанные данные и события, обязательно передайте `true` в качестве аргумента для `.clone()`.

## Removing Elements
Есть два способа удалить элементы со страницы: `.remove()` и `.detach()`. Используйте `.remove()`, если вы хотите навсегда удалить выборку со страницы. Хотя `.remove()` возвращает удаленные элементы, эти элементы не будут иметь связанных с ними данных и событий, если вы вернете их на страницу.

Используйте `.detach()`, если вам нужно, чтобы данные и события сохранялись. Как и `.remove()`, он возвращает выборку, но также поддерживает данные и события, связанные с выборкой, поэтому вы можете восстановить выборку на странице позже.

Метод `.detach()` чрезвычайно полезен, если вы выполняете тяжелые манипуляции с элементом. В этом случае полезно `.detach()` элемент со страницы, обработать его в своем коде, а затем восстановить его на странице, когда вы закончите. Это ограничивает дорогостоящие "прикосновения к DOM" при сохранении данных и событий элемента.

Если вы хотите оставить элемент на странице, но удалить его содержимое, вы можете использовать `.empty()` для удаления внутреннего HTML-кода элемента.

## Creating New Elements
jQuery предлагает простой и элегантный способ создания новых элементов с использованием того же метода `$()`, который используется для выбора:

    // Creating new elements from an HTML string.
    $( "<p>This is a new paragraph</p>" );
    $( "<li class=\"new\">new list item</li>" );

    // Creating a new element with an attribute object.
    $( "<a/>", {
      html: "This is a <strong>new</strong> link",
      "class": "new",
      href: "foo.html"
    });

Обратите внимание, что объект атрибутов во втором аргументе выше, имя свойства `class` заключено в кавычки, а имена свойств `html` и `href` - нет. Имена свойств обычно не нужно заключать в кавычки, если только они не являются зарезервированными словами (в данном случае это `class`).

Когда вы создаете новый элемент, он не сразу добавляется на страницу. Существует несколько способов добавить элемент на страницу после ее создания.

    // Getting a new element on to the page.
    var myNewElement = $( "<p>New element</p>" );
    myNewElement.appendTo( "#content" );
    myNewElement.insertAfter( "ul:last" ); // This will remove the p from #content!
    $( "ul" ).last().after( myNewElement.clone() ); // Clone the p so now we have two.

Созданный элемент не нужно хранить в переменной - вы можете вызвать метод для добавления элемента на страницу сразу после `$()`. Однако в большинстве случаев вам понадобится ссылка на добавленный вами элемент, чтобы вам не пришлось выбирать его позже.

Вы также можете создать элемент при его добавлении на страницу, но обратите внимание, что в этом случае вы не получите ссылку на вновь созданный элемент:

    // Creating and adding an element to the page at the same time.
    $( "ul" ).append( "<li>list item</li>" );

Синтаксис для добавления новых элементов на страницу прост, поэтому хочется забыть, что многократное добавление в DOM приводит к огромным потерям производительности. Если вы добавляете много элементов в один и тот же контейнер, вам нужно объединить весь HTML-код в одну строку, а затем добавить эту строку в контейнер вместо добавления элементов по одному. Используйте массив, чтобы собрать все части вместе, а затем соедините их в одну строку для добавления:

    var myItems = [];
    var myList = $( "#myList" );
    
    for ( var i = 0; i < 100; i++ ) {
        myItems.push( "<li>item " + i + "</li>" );
    }
    
    myList.append( myItems.join( "" ) );

## Manipulating Attributes
Возможности манипулирования атрибутами jQuery обширны. Основные изменения просты, но метод `.attr()` также позволяет выполнять более сложные манипуляции. Он может либо установить явное значение, либо установить значение, используя возвращаемое значение функции. При использовании синтаксиса функция получает два аргумента: отсчитываемый от нуля индекс элемента, атрибут которого изменяется, и текущее значение изменяемого атрибута.

    // Manipulating a single attribute.
    $( "#myDiv a:first" ).attr( "href", "newDestination.html" );

    // Manipulating multiple attributes.
    $( "#myDiv a:first" ).attr({
        href: "newDestination.html",
        rel: "nofollow"
    });

    // Using a function to determine an attribute's new value.
    $( "#myDiv a:first" ).attr({
      rel: "nofollow",
      href: function( idx, href ) {
          return "/new/" + href;
      }
    });

    $( "#myDiv a:first" ).attr( "href", function( idx, href ) {
      return "/new/" + href;
    });

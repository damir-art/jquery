# Iterating over jQuery and non-jQuery Objects
Перебор объектов jQuery и не-jQuery.

https://api.jquery.com/jQuery.each/
https://api.jquery.com/each/
https://api.jquery.com/jQuery.map/
https://api.jquery.com/map/

jQuery предоставляет утилиту итератора объектов, называемую `$.each()`, а также итератор коллекции jQuery: `.each()`. Они не взаимозаменяемы. Кроме того, есть несколько полезных методов, называемых `$.map()` и `.map()`, которые могут сократить один из наших распространенных вариантов использования итераций.

## $.each()
`$.each()` - это универсальная функция итератора для перебора объектов, массивов и объектов, подобных массивам. Обычные объекты итерируются по их именованным свойствам, а массивы и массивоподобные объекты итерируются по их индексам.

`$.each()` по сути является заменой традиционного цикла `for` или `for-in`.

## Работаем с массивом
Данный код:

    var sum = 0;
    var arr = [ 1, 2, 3, 4, 5 ];

    for ( var i = 0, l = arr.length; i < l; i++ ) {
      sum += arr[ i ];
    }

    console.log( sum ); // 15

Можно заменить на это:

    $.each( arr, function( index, value ){
      sum += value;
    });

    console.log( sum ); // 15

Обратите внимание, что нам не нужно обращаться к `arr[ index ]`, так как значение удобно передается обратному вызову в `$.each()`.

## Работаем с объектом

Данный код:

    var sum = 0;
    var obj = {
        foo: 1,
        bar: 2
    }

    for (var item in obj) {
        sum += obj[ item ];
    }

    console.log( sum ); // 3

Можно заменить на это:

    $.each( obj, function( key, value ) {
      sum += value;
    });

    console.log( sum ); // 3

Опять же, нам не нужно напрямую обращаться к `obj[ key ]`, так как значение передается непосредственно обратному вызову.

Обратите внимание, что `$.each()` предназначен для простых объектов, массивов, массивоподобных объектов, которые не являются коллекциями jQuery.

Такой код будет считаться неправильным:

    // Incorrect:
    $.each( $( "p" ), function() {
      // Do something
    });

Для коллекций jQuery используйте `.each()`.

## .each()
`.each()` используется непосредственно в коллекции jQuery. Он перебирает каждый соответствующий элемент в коллекции и выполняет обратный вызов для этого объекта. Индекс текущего элемента в коллекции передается в качестве аргумента функции обратного вызова. Значение (в данном случае элемент DOM) также передается, но обратный вызов запускается в контексте текущего сопоставленного элемента, поэтому ключевое слово `this` указывает на текущий элемент, как и ожидалось в других обратных вызовах jQuery.

Например, учитывая следующую разметку:

    <ul>
      <li><a href="#">Link 1</a></li>
      <li><a href="#">Link 2</a></li>
      <li><a href="#">Link 3</a></li>
    </ul>

`.each()` можно использовать так:

    $( "li" ).each( function( index, element ){
      console.log( $( this ).text() );
    });
    
    // Logs the following:
    // Link 1
    // Link 2
    // Link 3

## Второй аргумент
Часто возникает вопрос: *"Если это элемент, то почему в функцию обратного вызова передается второй аргумент элемента DOM?"*

Преднамеренно или непреднамеренно контекст выполнения может измениться. При последовательном использовании ключевого слова `this` легко запутать себя или других разработчиков, читающих код. Даже если контекст выполнения остается прежним, может быть удобнее использовать второй параметр в качестве именованного параметра. Например:

    $( "li" ).each( function( index, listItem ) {
      this === listItem; // true
      // For example only. You probably shouldn't call $.ajax() in a loop.
      $.ajax({
        success: function( data ) {
          // The context has changed.
          // The "this" keyword no longer refers to listItem.
          this !== listItem; // true
        }
      });
    });

## Иногда .each() не требуется
Многие методы jQuery неявно перебирают всю коллекцию, применяя свое поведение к каждому соответствующему элементу. Например, это необязательно:

    $( "li" ).each( function( index, el ) {
      $( el ).addClass( "newClass" );
    });

И это нормально:

    $( "li" ).addClass( "newClass" );

К каждому элементу `<li>` в документе будет добавлен класс `newClass`.

С другой стороны, некоторые методы не перебирают коллекцию. `.each()` требуется, когда нам нужно получить информацию от элемента перед установкой нового значения.

Так не пойдет:

    // Doesn't work:
    $( "input" ).val( $( this ).val() + "%" );
    // .val() does not change the execution context, so this === window

Вернее, так это должно быть написано:

    $( "input" ).each( function( i, el ) {
        var elem = $( el );
        elem.val( elem.val() + "%" );
    });

Ниже приведен список методов, для которых требуется `.each()`:

    .attr() (getter)
    .css() (getter)
    .data() (getter)
    .height() (getter)
    .html() (getter)
    .innerHeight()
    .innerWidth()
    .offset() (getter)
    .outerHeight()
    .outerWidth()
    .position()
    .prop() (getter)
    .scrollLeft() (getter)
    .scrollTop() (getter)
    .val() (getter)
    .width() (getter)

Обратите внимание, что в большинстве случаев сигнатура `геттер` возвращает результат для первого элемента в коллекции jQuery, в то время как сеттер действует над всей коллекцией совпадающих элементов. Исключением является `.text()`, где сигнатура получателя возвращает объединенную строку текста из всех совпадающих элементов.

В дополнение к сеттеру, значения, атрибуты, свойства, сеттеры CSS и методы сеттера вставки DOM (т.е. `.text()` и `.html()`) принимают анонимные функции обратного вызова, которые применяются к каждому элементу в соответствующем наборе. Аргументы, передаваемые обратному вызову, представляют собой индекс соответствующего элемента в наборе и результат сигнатуры "получателя" метода.

Например, они эквивалентны:

    $( "input" ).each( function( i, el ) {
      var elem = $( el );
      elem.val( elem.val() + "%" );
    });
    
    $( "input" ).val(function( index, value ) {
        return value + "%";
    });

Еще одна вещь, о которой следует помнить при этой неявной итерации, заключается в том, что методы обхода, такие как `.children()` или `.parent()`, будут воздействовать на каждый соответствующий элемент в коллекции, возвращая объединенную коллекцию всех дочерних или родительских узлов.

## .map()
Существует распространенный вариант использования итерации, который лучше обрабатывать с помощью метода `.map()`. Каждый раз, когда мы хотим создать массив или конкатенированную строку на основе всех совпадающих элементов в нашем селекторе jQuery, нам лучше использовать `.map()`.

Например, вместо этого:

    var newArr = [];

    $( "li" ).each( function() {
      newArr.push( this.id );
    });

Мы можем сделать это:

    $( "li" ).map( function(index, element) {
      return this.id;
    }).get();

Обратите внимание на цепочку `.get()` в конце. `.map()` фактически возвращает коллекцию, обернутую jQuery, даже если мы возвращаем строки из обратного вызова. Нам нужно использовать версию `.get()` без аргументов, чтобы вернуть базовый массив JavaScript, с которым мы можем работать. Чтобы объединиться в строку, мы можем связать простой метод массива JS `.join()` после `.get()`.

## $.map()
Подобно `$.each()` и `.each()`, существует `$.map()` и `.map()`. Разница также очень похожа на оба метода `.each()`. `$.map()` работает с простыми массивами JavaScript, а `.map()` работает с коллекциями элементов jQuery. Поскольку он работает с простым массивом, `$.map()` возвращает простой массив, а `.get()` не нужно вызывать - на самом деле он выдаст ошибку, поскольку это не собственный метод JavaScript.

Предупреждение: `$.map()` меняет порядок аргументов обратного вызова. Это было сделано для того, чтобы соответствовать нативному методу JavaScript `.map()`, доступному в ECMAScript 5.

Пример:

    <li id="a"></li>
    <li id="b"></li>
    <li id="c"></li>

    <script>
      var arr = [
        { id: "a", tagName: "li" },
        { id: "b", tagName: "li" },
        { id: "c", tagName: "li" }
      ];

      // Returns [ "a", "b", "c" ]
      $( "li" ).map( function( index, element ) {
        return element.id;
      }).get();

      // Also returns [ "a", "b", "c" ]
      // Note that the value comes first with $.map
      $.map( arr, function( value, index ) {
        return value.id;
      });
    </script>
